= Evaluation of Notification Delivery Approaches (In-App vs Push)
:Author: Team 2 – Alerts & Restock


== 1. Introduction

This document evaluates notification delivery approaches for the Alerts & Restock feature in the Digital Home Inventory system. The goal is to determine the most appropriate and architecturally sound notification strategy compatible with a Supabase-based backend.

The system must notify users when:

* Items are expiring soon or have expired (R1 – Expiration Logic)
* Items are low in stock (R2 – Low Stock Logic)
* Alerts are generated automatically by the scheduled check system (R3 – Automated Check System)

This research compares two primary approaches:

* In-App Notifications
* Push Notifications

== 2. Option 1: In-App Notifications

=== 2.1 Description

In-app notifications are stored in the database and displayed inside the application interface when the user opens the app.

Notifications are generated by backend logic and saved in a `notifications` table. The frontend queries this table and displays unread notifications.

=== 2.2 Required Infrastructure

* notifications table in Supabase
* Relationship between user_id and notifications
* Alert status fields (read/unread/dismissed)
* Backend function to insert notification records when alerts are triggered

No external services are required.

=== 2.3 Advantages

* Simple architecture
* Fully controlled within Supabase
* No dependency on external push providers
* Easier to test
* Lower implementation complexity
* No device token management required

=== 2.4 Disadvantages

* User must open the app to see notifications
* No real-time device-level alerts
* Lower immediacy compared to push notifications

=== 2.5 Scalability

Highly scalable since it only relies on database inserts and reads. Supabase handles standard relational scaling.

== 3. Option 2: Push Notifications

=== 3.1 Description

Push notifications are device-level alerts sent to registered devices even when the app is closed.

This typically requires integration with services such as:

* Firebase Cloud Messaging (FCM)
* Apple Push Notification Service (APNs)

=== 3.2 Required Infrastructure

* Device registration table (device_token, platform, user_id)
* Secure storage of tokens
* Backend function to trigger push API
* Integration with external notification provider
* Error handling and retry logic

=== 3.3 Advantages

* Immediate user awareness
* Higher engagement
* Real-time alerts even when app is closed

=== 3.4 Disadvantages

* Increased architectural complexity
* External service dependency
* Token lifecycle management required
* More complex testing and debugging
* Platform-specific behavior differences

=== 3.5 Scalability

Push systems are scalable but require careful rate limiting, token management, and error handling.

== 4. Architectural Comparison

[cols="1,1,1", options="header"]
|===
|Criteria |In-App Notifications |Push Notifications

|Implementation Complexity
|Low
|Medium–High

|External Dependencies
|None
|Required

|Device Management
|Not Required
|Required

|User Awareness
|When app is opened
|Immediate

|Maintenance Overhead
|Low
|Medium–High

|Alignment with Milestone Scope
|Strong
|Moderate
|===

== 5. Recommendation

For the current scope of the Digital Home Inventory project, the recommended approach is:

**Primary Approach: In-App Notifications**

Justification:

* Aligns with Milestone 1 (research and system design only).
* Lower architectural complexity.
* Fully compatible with Supabase without external integrations.
* Easier to test and document.
* Sufficient for academic and prototype-level system goals.

Future Enhancement:

Push notifications may be considered in a later milestone once the alert generation and automation layers are stable.

== 6. High-Level Notification Flow (In-App Model)

1. R1/R2 define alert conditions.
2. R3 automated job runs daily sweep.
3. If alert condition is met → alert record is created.
4. Notification record is inserted into notifications table.
5. User opens app.
6. App queries unread notifications.
7. User views and optionally dismisses notification.

== 7. Architectural Implications

The in-app notification model requires:

* A notifications table
* Foreign key relationship with users
* Alert type classification (expiration, low_stock)
* Status field (unread, read, dismissed)
* Timestamp tracking
* Optional severity level

This model integrates cleanly with:

* R3 Automated Check System (alert creation)
* R1 Expiration Logic
* R2 Low Stock Logic
* Future Grocery List auto-generation

== 8. Conclusion

After evaluating both notification delivery strategies, the in-app notification approach provides the best balance of simplicity, architectural clarity, and feasibility within the scope of Milestone 1.

This decision establishes a stable foundation for designing the Notification/Alerts System without introducing unnecessary complexity at this stage.